<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深海的鲸的鱼塘</title>
  
  <subtitle>为何而愁？</subtitle>
  <link href="https://heugzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://heugzh.github.io/"/>
  <updated>2021-06-28T09:12:28.610Z</updated>
  <id>https://heugzh.github.io/</id>
  
  <author>
    <name>深海的鲸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集</title>
    <link href="https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-05-18T14:51:12.000Z</published>
    <updated>2021-06-28T09:12:28.610Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >并查集算法的基本概念</strong></div><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>并查集主要用于解决一些元素分组的问题，它管理一系列的<strong>不相交</strong>的集合。并且支持两种操作：</p><ul><li>合并（Union）：把两个集合合并成一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合。</li></ul></blockquote><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认初始状态每个结点都为根结点。</p><p><strong>查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( fa[x]==x )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层层访问其父节点，直到根节点。判断两个元素是否是属于同一个集合，只需要看他们的根节点是否相同。</p><p><strong>合并</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> fi,<span class="keyword">int</span> se)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(fi)] = <span class="built_in">find</span>(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第一个集合的根结点挂载到第二个集合根节点。</p><p>上述的简单合并效率是很低的，尤其在出现了很长的链的情况下，访问根节点会需要很长的时间。最重要的是大部分题目使用上述方法会超时，所以需要优化其代码。</p><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>可以采用路径压缩的方式，集合合并的时候我们只关心根节点而不关心中间的遍历过程。那么我们可以在查询的时候将路径上的每个节点的父节点都改为根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>[fa[x]];</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者简写为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x== fa[x] ? x  :( fa[x]=<span class="built_in">find</span>(fa[x]) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>经过路径压缩之后的并查集并不是一个只有两层的树，因为路径压缩只是在查询的时候进行，并且也只是压缩了其中一条路径。所以很多时候其结果仍然很复杂。当两颗树合并时，如果把简单的树往复杂的树上合并，最后的结果相对更简单。</p><p>所以有了一种新的优化策略，即按秩合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt;= rank[y] )</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">   <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x!=y )</span><br><span class="line">       rank[y]++; <span class="comment">// 深度相同，挂载后树的高度加一。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然懂了原理，还需要实践。可以去<a href="https://www.luogu.com.cn/">落谷</a>或者<a href="https://leetcode-cn.com/">leetcode</a>刷刷题。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;并查集算法的基本概念&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置</title>
    <link href="https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/"/>
    <id>https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/</id>
    <published>2021-05-16T06:32:21.000Z</published>
    <updated>2021-06-28T09:11:08.219Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >重新布置博客主题</strong></div><a id="more"></a><h1 id="安装所需环境"><a href="#安装所需环境" class="headerlink" title="安装所需环境"></a>安装所需环境</h1><p>首先需要安装git以及node.js。直接去对应的官网下载就好。git版本无所谓，但是node.js的版本就很重要。大部分博客主题是基于node.js v14之前的写的（node v14似乎做了一次大改），所以如果版本不匹配，会发生一些问题（错误会在本篇最后具体描述）。所以最好安装node.js v14之前的版本。</p><h1 id="hexo主题配置"><a href="#hexo主题配置" class="headerlink" title="hexo主题配置"></a>hexo主题配置</h1><p>首先使用 npm 安装 hexo-cli 。</p><p><code> npm install hexo-cli -g</code></p><p>然后找一个空的文件夹 执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后访问localhost:4000, 就能看到默认的一个hexo主题。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>默认主题说实话，太丑了。得换。</p><p>可以在 <a href="https://hexo.io/themes/"> hexo官网 </a>找一个好康的主题。</p><p>首先，下载主题。我使用的是indigo主题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git</span><br></pre></td></tr></table></figure><p>然后把下载的文件夹放到<code>blog/themes</code>。</p><p>接下来，更新hexo 的版本。hexo v5也是大改过的版本。至少indigo主题不支持hexo v5。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo@4.0.0</span><br></pre></td></tr></table></figure><p>安装 indigo所需依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-less --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure><p>修改blog 下的<code>_config</code>文件，修改theme 为 hexo-theme-indigo。</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以在本地 localhost:4000 看到新的主题。</p><h1 id="谈谈问题"><a href="#谈谈问题" class="headerlink" title="谈谈问题"></a>谈谈问题</h1><p>版本匹配真的是一个坑，indigo主题只是说了使用hexo v3.0+ 和node v6.0+。然后下载的时候下载最新版本的hexo和node会直接g掉。</p><h2 id="node版本不匹配会遇到的问题"><a href="#node版本不匹配会遇到的问题" class="headerlink" title="node版本不匹配会遇到的问题"></a>node版本不匹配会遇到的问题</h2><p>node 版本如果是14以上的话，执行<code>hexo s</code>命令是没有问题的。<code>hexo g</code> 本来是应该将markdown文章解析之后放入public文件夹。事实是，public里面的<code>index.html</code> 是一个空白文件。<code> hexo s</code>能显示正常。但是当<code>hexo  d</code>(该命令用于部署到网上)，执行的时候是把public里面的文件给提交上去。</p><h2 id="hexo版本不匹配所遇到的问题"><a href="#hexo版本不匹配所遇到的问题" class="headerlink" title="hexo版本不匹配所遇到的问题"></a>hexo版本不匹配所遇到的问题</h2><p>由于hexo v5.0 将<code>lodash</code>从全局变量中移除。 所以<code> hexo g</code> 执行的时候会出现大量的 <code>_</code>未定义。</p>]]></content>
    
    
    <summary type="html">这是一次测试项目</summary>
    
    
    
    <category term="博客配置" scheme="https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="https://heugzh.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
