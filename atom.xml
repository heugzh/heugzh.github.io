<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深海的鲸的鱼塘</title>
  
  <subtitle>或许是不知梦的缘故,流离之人追逐幻影</subtitle>
  <link href="https://heugzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://heugzh.github.io/"/>
  <updated>2022-04-16T10:50:20.242Z</updated>
  <id>https://heugzh.github.io/</id>
  
  <author>
    <name>深海的鲸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaSE回顾</title>
    <link href="https://heugzh.github.io/2022/04/16/javaSE%E5%9B%9E%E9%A1%BE/"/>
    <id>https://heugzh.github.io/2022/04/16/javaSE%E5%9B%9E%E9%A1%BE/</id>
    <published>2022-04-16T10:41:45.000Z</published>
    <updated>2022-04-16T10:50:20.242Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>此处为标题显示</strong></div><a id="more"></a><h1 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h1><h2 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h2><p>java的虚拟机屏蔽了不同软硬件平台，java应用程序不需要修改，不需要重新编译就可以在其他平台运行。java虚拟机在java应用程序和操作系统之间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//image-20220214105145997.png" alt="image-20220214105145997" title>                </div>                <div class="image-caption">image-20220214105145997</div>            </figure><h2 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h2><p>一个源程序文件包含多个类时，需要注意如下问题： </p><ol><li>只能有一个类声明为公有（public）的。 </li><li>文件命名必须与公有类名完全一致，包括字母大小写。 </li><li>public static void main(String[] args)只能定义在公有类中。 </li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="输出打印方法"><a href="#输出打印方法" class="headerlink" title="输出打印方法"></a>输出打印方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(String s)<span class="comment">//打印字符串不换行，有多个重载方法，可以打印任何类型数据.</span></span><br><span class="line">println(String x)<span class="comment">//打印字符串换行，有多个重载方法，可以打印任何类型数据。 </span></span><br><span class="line">printf(String format, Object... args) <span class="comment">//使用指定输出格式，打印任何长度的数据， 但不换行。 修</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>//  单行 注释</p><p>/* */ 多行注释 </p><p>/** */ 文档注释  文档注释用在类、方法、变量上面，用来描述其作用。当鼠标放到其上时会显示注释内容。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>用final关键字来定义： final int LENGTH = 10 .一般常量名是大写字母.常量定义后就不能修改了。<br>常量有3种：</p><ul><li>静态常量 public static final int LENGTH=10;（作用域是全局，不需要创建对象就可以访问，在类外部的访问形式为类名.常量名)</li><li>成员常量，即定义在类中的 final int y=10;作用域和成员变量一致。</li><li>局部常量，即定义在方法中的final int y=10;作用域和局部变量一致。</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>命名：必须以字母或下划线或￥或$开头。</li><li>多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔。</li><li>变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。</li><li>方法中的变量必须显式地初始化，否则在使用该变量时就会出错。</li></ul><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>成员变量，默认是public修饰</p><ul><li>静态变量(类变量)，有static修饰，作用域取决于类的生命周期。</li><li>全局变量，无static修饰，作用域取决于对象。<br>  局部变量</li><li>方法参数变量（形参）：在整个方法内有效。</li><li>方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。</li><li>代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。</li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//image-20220214114705643.png" alt="image-20220214114705643" title>                </div>                <div class="image-caption">image-20220214114705643</div>            </figure><ul><li><code>char</code> 是用两个字节来表示Unicode码。</li><li><code>boolean</code>  java中布尔类型是不能装换成任何数据类型,只有true和false两种取值，但是0和非0是能转换成布尔类型的。</li><li><code>float</code>类型数据定义时必须加<code>f</code>。</li><li>除了基本类型，其他都是引用类型。</li></ul><h3 id="进制数"><a href="#进制数" class="headerlink" title="进制数"></a>进制数</h3><ul><li>二进制：<code>0b</code>开头。</li><li>八进制：<code>0</code>开头。</li><li>十六进制：<code>0x</code>开头。</li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//image-20220214120150732.png" alt="image-20220214120150732" title>                </div>                <div class="image-caption">image-20220214120150732</div>            </figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(类型 变量名:集合)&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能用于遍历，而不能修改集合中的元素。</p><h4 id="带标签的break"><a href="#带标签的break" class="headerlink" title="带标签的break"></a>带标签的break</h4><p>break后面接一个标签，可以跳出到设置标签的地方。标签可以指定一个代码块，但是代码块必须包围break。（continue也可以带标签）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> y = <span class="string">'1'</span>;</span><br><span class="line">lble:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            System.out.print(y);</span><br><span class="line">                <span class="keyword">break</span> lble;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="keyword">float</span>[] b;</span><br><span class="line"><span class="comment">// 数组声明完成之后，数组的长度还不能确定。</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 动态初始化，使用new分配长度</span></span><br><span class="line"><span class="keyword">int</span>[] a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// new 生成的数组的值默认是‘0’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] array1;</span><br><span class="line"><span class="keyword">int</span> array1[][];</span><br><span class="line"><span class="keyword">int</span>[] array1[];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">array1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> array2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];<span class="comment">// 4是高维。</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h3><p>使用new关键字创建字符串和直接使用字符串常量有所区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span> ; </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 使用==号判别时，只有s1 和s2 相等。</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//image-20220215091138043.png" alt="image-20220215091138043" title>                </div>                <div class="image-caption">image-20220215091138043</div>            </figure><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello "</span>;</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">s +=<span class="string">"world"</span>;</span><br><span class="line">s = s.concat(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(); </span><br><span class="line">String s= <span class="string">"ld"</span>;</span><br><span class="line"><span class="keyword">int</span> fistchar = s.indexOf(ch,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">int</span> lastchar = s.lastIndexOf(ch,len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line">s1 = <span class="string">"hi"</span>;</span><br><span class="line">s2 = <span class="string">"hi"</span>;</span><br><span class="line">s3 = <span class="string">"zoo"</span>;</span><br><span class="line">s1.equals(s2);</span><br><span class="line">s1.compareTo(s3);<span class="comment">//此字符串等于参数字符串返回0,小于返回一个小于0的数，大于返回一个大于0的数</span></span><br><span class="line"><span class="comment">// 截取</span></span><br><span class="line">String s = <span class="string">"this is a test"</span>;</span><br><span class="line">String subs = s.substring(<span class="number">2</span>); <span class="comment">//从索引2开始截取</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象有三个基本特性：封装、继承、多态。</p><ul><li>封装：将对象内部细节隐藏。</li><li>继承：子类继承父类，避免重复行为的定义。</li><li>多态：子类继承父类后，可以具有和父类不同的状态或者表现行为。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> c = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>同一个包中的各个类直接调用，不同包中的类需要使用import关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>一个类中多个同名方法。根据参数个数或者类型不同，确定使用哪个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"快吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"吃饭时间"</span>+ time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ul><li>private ：只允许在类的内部使用。</li><li>默认级别 ：没有修饰符，可以在同一个包中的其他类访问。</li><li>protected ：同一个包中与默认级别一样，不同包中只能继承访问。</li><li>public ：都能访问。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">new</span> String(<span class="string">"hello"</span>);<span class="comment">//调用了String的构造函数实例化对象</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以重载，且构造方法名与类名相同，没有返回值，与new结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    String shape;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(Stirng s ,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        shape =s;</span><br><span class="line">        width =w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(string s, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        shape =s;</span><br><span class="line">        length =l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li>调用实例变量</li><li>调用实例方法</li><li>调用其他构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> Date birthDate; </span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 三个参数构造方法  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">this</span>.name = name;      </span><br><span class="line">     <span class="keyword">this</span>.age = age;      </span><br><span class="line">     birthDate = d;   </span><br><span class="line">     System.out.println(<span class="keyword">this</span>.toString());    </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;     </span><br><span class="line">     <span class="comment">// 调用三个参数构造方法   </span></span><br><span class="line">     <span class="keyword">this</span>(name, age, <span class="keyword">null</span>);  </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", birthDate="</span> + birthDate + <span class="string">"]"</span>;  </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为 该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾 收集起来并释放。 </p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当子类实例化时，不仅需要初始化子类的成员，还得初始化父类的成员变量，调用父类的构造方法使用<code>super</code>(和this使用一样)。或者可以显式的给父类写一个默认构造方法。</p><h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h3><p>方法覆盖，当子类方法完全和父类方法相同时（不包括修饰符，子类修饰符范围应该大于父类），子类方法覆盖父类的方法。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态发生的三个条件：</p><ul><li>继承</li><li>覆盖</li><li>声明变量类型是父类类型，但是实例指向了子类实例</li></ul><h3 id="引用类型检查运算符"><a href="#引用类型检查运算符" class="headerlink" title="引用类型检查运算符"></a>引用类型检查运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student <span class="keyword">instanceof</span> Person <span class="comment">// 是返回true，否则返回false</span></span><br></pre></td></tr></table></figure><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 关键字修饰的局部变量和成员变量只能赋值一次。final修饰的类不能被继承。final修饰的父类方法不能被子类不能被覆盖。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>具有抽象的方法。一个方法被声明为抽象的，则其类也得为抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计抽象方法就是为了让子类来实现。抽象类不能实例化。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rect</span> <span class="keyword">implements</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"绘制矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 为单继承，但是接口可以继承多个。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能存在的异常语句。</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">    e.printStrackTrace();</span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try后面可以加()放入资源申请语句，可以自动释放资源，就不需要finally。</p><p>throw抛出异常，throws声明异常类。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//image-20220215163947324.png" alt="image-20220215163947324" title>                </div>                <div class="image-caption">image-20220215163947324</div>            </figure><p>不使用泛型也可以，但是不符合编码规范。那是为了兼容以前的版本。</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>Java SE 提供 4 个顶 级抽象类，两个字节流抽象类：InputStream 和OutputStream；两个字符流抽象类：Reader 和 Writer。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class t = Class.forname(<span class="string">"User"</span>); <span class="comment">// 参数为类名，将该类加载到jvm中。</span></span><br><span class="line">t.<span class="keyword">instanceof</span>() <span class="comment">// 实例化类</span></span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>常见的设计模式。为一个对象提供代理，用来控制对这个对象的访问。</p><p>代理类设计原则：</p><ol><li>代理类和委托类具有相似的行为。（父类或者负接口）</li><li>代理类增强委托类。</li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ol><li>目标角色固定</li><li>应用程序执行前就得到目标角色</li><li>代理对象增强目标的行为</li><li>有可能存在多个代理，引发爆炸。</li></ol><p>自己手写。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>根据反射机制，在运行时动态产生。增强目标对象的行为。目标对象不固定。</p><ol><li>JDK动态代理</li><li>CGL动态代理</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>必须有接口实现。委托给代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Proxy代理类中的静态方法newProxyInstance()有三个参数</span></span><br><span class="line"><span class="comment">//类加载器</span></span><br><span class="line"><span class="comment">//代理对象接口</span></span><br><span class="line"><span class="comment">//一个InvocationHandler接口</span></span><br><span class="line"><span class="comment">//返回一个指定接口的代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdkProxy</span></span>&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object taget;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">jdkProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过调用Proxy的newProxyInstance()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLiader loader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 没有目标对象，就不能通过jdk动态代理</span></span><br><span class="line">        Class[] interfaces = target.getClas().getInterfaces();</span><br><span class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="comment">//当代理对象调用方法时，invoke会被执行一次</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"test"</span>);</span><br><span class="line">            <span class="comment">//通过反射中的 invoke方法调用指定对象的指定方法</span></span><br><span class="line">            <span class="comment">//调用target的mthod方法。args参数</span></span><br><span class="line">            Object reuslt = method.invoke(target,args);</span><br><span class="line">            <span class="comment">//方法的返回值</span></span><br><span class="line">            <span class="keyword">return</span> result；</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">        Object object  = Proxy.newProxyInstance(loader,interfaces,invocationHandler);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starte</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//得到目标对象</span></span><br><span class="line">        Student student  = <span class="keyword">new</span> Student();<span class="comment">//Student 实现了 Person接口。</span></span><br><span class="line">        <span class="comment">// 得到代理类</span></span><br><span class="line">        jdkProxy proxy = <span class="keyword">new</span> jdkProxy(student);</span><br><span class="line">        <span class="comment">//得到代理对象</span></span><br><span class="line">        Student object = (Student) jdkProxy.getProxy();</span><br><span class="line">        object.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK只能代理实现了接口的类，CGLIB对指定的目标类生成一个子类，覆盖里面的方法。采用继承，父类不能用final修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 定义方法拦截器</span></span><br><span class="line">        MethodInterceptor methodInterceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置代理过程</span></span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line">        <span class="comment">//生成一个类</span></span><br><span class="line">        <span class="keyword">return</span>  enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starte</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//得到目标对象</span></span><br><span class="line">        Student student  = <span class="keyword">new</span> Student();<span class="comment">//Student 继承了Person类。</span></span><br><span class="line">        <span class="comment">// 得到代理类</span></span><br><span class="line">        jdkProxy proxy = <span class="keyword">new</span> CglibProxy(student);</span><br><span class="line">        <span class="comment">//得到代理对象</span></span><br><span class="line">        Student object = (Student) CglibProxy.getProxy();</span><br><span class="line">        object.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;此处为标题显示&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java SE</title>
    <link href="https://heugzh.github.io/2022/04/16/javabase/"/>
    <id>https://heugzh.github.io/2022/04/16/javabase/</id>
    <published>2022-04-16T09:51:12.000Z</published>
    <updated>2022-04-16T10:30:58.067Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>Java基础回顾</strong></div><a id="more"></a><h1 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h1><h2 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h2><p>java的虚拟机屏蔽了不同软硬件平台，java应用程序不需要修改，不需要重新编译就可以在其他平台运行。java虚拟机在java应用程序和操作系统之间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//Users\hy\AppData\Roaming\Typora\typora-user-images\image-20220214105145997.png" alt="image-20220214105145997" title>                </div>                <div class="image-caption">image-20220214105145997</div>            </figure><h2 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h2><p>一个源程序文件包含多个类时，需要注意如下问题： </p><ol><li>只能有一个类声明为公有（public）的。 </li><li>文件命名必须与公有类名完全一致，包括字母大小写。 </li><li>public static void main(String[] args)只能定义在公有类中。 </li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="输出打印方法"><a href="#输出打印方法" class="headerlink" title="输出打印方法"></a>输出打印方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(String s)<span class="comment">//打印字符串不换行，有多个重载方法，可以打印任何类型数据.</span></span><br><span class="line">println(String x)<span class="comment">//打印字符串换行，有多个重载方法，可以打印任何类型数据。 </span></span><br><span class="line">printf(String format, Object... args) <span class="comment">//使用指定输出格式，打印任何长度的数据， 但不换行。 修</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>//  单行 注释</p><p>/* */ 多行注释 </p><p>/** */ 文档注释  文档注释用在类、方法、变量上面，用来描述其作用。当鼠标放到其上时会显示注释内容。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>用final关键字来定义： final int LENGTH = 10 .一般常量名是大写字母.常量定义后就不能修改了。<br>常量有3种：</p><ul><li>静态常量 public static final int LENGTH=10;（作用域是全局，不需要创建对象就可以访问，在类外部的访问形式为类名.常量名)</li><li>成员常量，即定义在类中的 final int y=10;作用域和成员变量一致。</li><li>局部常量，即定义在方法中的final int y=10;作用域和局部变量一致。</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>命名：必须以字母或下划线或￥或$开头。</li><li>多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔。</li><li>变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。</li><li>方法中的变量必须显式地初始化，否则在使用该变量时就会出错。<h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4>成员变量，默认是public修饰</li><li>静态变量(类变量)，有static修饰，作用域取决于类的生命周期。</li><li>全局变量，无static修饰，作用域取决于对象。<br>局部变量</li><li>方法参数变量（形参）：在整个方法内有效。</li><li>方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。</li><li>代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//Users\hy\AppData\Roaming\Typora\typora-user-images\image-20220214114705643.png" alt="image-20220214114705643" title>                </div>                <div class="image-caption">image-20220214114705643</div>            </figure><ul><li><code>char</code> 是用两个字节来表示Unicode码。</li><li><code>boolean</code>  java中布尔类型是不能装换成任何数据类型,只有true和false两种取值，但是0和非0是能转换成布尔类型的。</li><li><code>float</code>类型数据定义时必须加<code>f</code>。</li><li>除了基本类型，其他都是引用类型。<h3 id="进制数"><a href="#进制数" class="headerlink" title="进制数"></a>进制数</h3></li></ul><ul><li>二进制：<code>0b</code>开头。</li><li>八进制：<code>0</code>开头。</li><li>十六进制：<code>0x</code>开头。</li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//Users\hy\AppData\Roaming\Typora\typora-user-images\image-20220214120150732.png" alt="image-20220214120150732" title>                </div>                <div class="image-caption">image-20220214120150732</div>            </figure><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for-each循环"></a>for-each循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(类型 变量名:集合)&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能用于遍历，而不能修改集合中的元素。</p><h4 id="带标签的break"><a href="#带标签的break" class="headerlink" title="带标签的break"></a>带标签的break</h4><p>break后面接一个标签，可以跳出到设置标签的地方。标签可以指定一个代码块，但是代码块必须包围break。（continue也可以带标签）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> y = <span class="string">'1'</span>;</span><br><span class="line">lble:<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            System.out.print(y);</span><br><span class="line">                <span class="keyword">break</span> lble;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="keyword">float</span>[] b;</span><br><span class="line"><span class="comment">// 数组声明完成之后，数组的长度还不能确定。</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 动态初始化，使用new分配长度</span></span><br><span class="line"><span class="keyword">int</span>[] a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// new 生成的数组的值默认是‘0’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] array1;</span><br><span class="line"><span class="keyword">int</span> array1[][];</span><br><span class="line"><span class="keyword">int</span>[] array1[];</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">array1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> array2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];<span class="comment">// 4是高维。</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h3><p>使用new关键字创建字符串和直接使用字符串常量有所区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span> ; </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 使用==号判别时，只有s1 和s2 相等。</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//Users\hy\AppData\Roaming\Typora\typora-user-images\image-20220215091138043.png" alt="image-20220215091138043" title>                </div>                <div class="image-caption">image-20220215091138043</div>            </figure><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello "</span>;</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">s +=<span class="string">"world"</span>;</span><br><span class="line">s = s.concat(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">int</span> len = s.length(); </span><br><span class="line">String s= <span class="string">"ld"</span>;</span><br><span class="line"><span class="keyword">int</span> fistchar = s.indexOf(ch,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">int</span> lastchar = s.lastIndexOf(ch,len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较</span></span><br><span class="line">s1 = <span class="string">"hi"</span>;</span><br><span class="line">s2 = <span class="string">"hi"</span>;</span><br><span class="line">s3 = <span class="string">"zoo"</span>;</span><br><span class="line">s1.equals(s2);</span><br><span class="line">s1.compareTo(s3);<span class="comment">//此字符串等于参数字符串返回0,小于返回一个小于0的数，大于返回一个大于0的数</span></span><br><span class="line"><span class="comment">// 截取</span></span><br><span class="line">String s = <span class="string">"this is a test"</span>;</span><br><span class="line">String subs = s.substring(<span class="number">2</span>); <span class="comment">//从索引2开始截取</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象有三个基本特性：封装、继承、多态。</p><ul><li>封装：将对象内部细节隐藏。</li><li>继承：子类继承父类，避免重复行为的定义。</li><li>多态：子类继承父类后，可以具有和父类不同的状态或者表现行为。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> c = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>同一个包中的各个类直接调用，不同包中的类需要使用import关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>一个类中多个同名方法。根据参数个数或者类型不同，确定使用哪个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"快吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"吃饭时间"</span>+ time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ul><li>private ：只允许在类的内部使用。</li><li>默认级别 ：没有修饰符，可以在同一个包中的其他类访问。</li><li>protected ：同一个包中与默认级别一样，不同包中只能继承访问。</li><li>public ：都能访问。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">new</span> String(<span class="string">"hello"</span>);<span class="comment">//调用了String的构造函数实例化对象</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以重载，且构造方法名与类名相同，没有返回值，与new结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    String shape;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(Stirng s ,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        shape =s;</span><br><span class="line">        width =w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(string s, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        shape =s;</span><br><span class="line">        length =l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul><li>调用实例变量</li><li>调用实例方法</li><li>调用其他构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> Date birthDate; </span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 三个参数构造方法  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">this</span>.name = name;      </span><br><span class="line">     <span class="keyword">this</span>.age = age;      </span><br><span class="line">     birthDate = d;   </span><br><span class="line">     System.out.println(<span class="keyword">this</span>.toString());    </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;     </span><br><span class="line">     <span class="comment">// 调用三个参数构造方法   </span></span><br><span class="line">     <span class="keyword">this</span>(name, age, <span class="keyword">null</span>);  </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", birthDate="</span> + birthDate + <span class="string">"]"</span>;  </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为 该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾 收集起来并释放。 </p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当子类实例化时，不仅需要初始化子类的成员，还得初始化父类的成员变量，调用父类的构造方法使用<code>super</code>(和this使用一样)。或者可以显式的给父类写一个默认构造方法。</p><h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h3><p>方法覆盖，当子类方法完全和父类方法相同时（不包括修饰符，子类修饰符范围应该大于父类），子类方法覆盖父类的方法。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态发生的三个条件：</p><ul><li>继承</li><li>覆盖</li><li>声明变量类型是父类类型，但是实例指向了子类实例</li></ul><h3 id="引用类型检查运算符"><a href="#引用类型检查运算符" class="headerlink" title="引用类型检查运算符"></a>引用类型检查运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student <span class="keyword">instanceof</span> Person <span class="comment">// 是返回true，否则返回false</span></span><br></pre></td></tr></table></figure><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 关键字修饰的局部变量和成员变量只能赋值一次。final修饰的类不能被继承。final修饰的父类方法不能被子类不能被覆盖。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>具有抽象的方法。一个方法被声明为抽象的，则其类也得为抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计抽象方法就是为了让子类来实现。抽象类不能实例化。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rect</span> <span class="keyword">implements</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"绘制矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 为单继承，但是接口可以继承多个。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能存在的异常语句。</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">    e.printStrackTrace();</span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try后面可以加()放入资源申请语句，可以自动释放资源，就不需要finally。</p><p>throw抛出异常，throws声明异常类。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/.io//Users\hy\AppData\Roaming\Typora\typora-user-images\image-20220215163947324.png" alt="image-20220215163947324" title>                </div>                <div class="image-caption">image-20220215163947324</div>            </figure><p>不使用泛型也可以，但是不符合编码规范。那是为了兼容以前的版本。</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>Java SE 提供 4 个顶 级抽象类，两个字节流抽象类：InputStream 和OutputStream；两个字符流抽象类：Reader 和 Writer。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class t = Class.forname(<span class="string">"User"</span>); <span class="comment">// 参数为类名，将该类加载到jvm中。</span></span><br><span class="line">t.<span class="keyword">instanceof</span>() <span class="comment">// 实例化类</span></span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>常见的设计模式。为一个对象提供代理，用来控制对这个对象的访问。</p><p>代理类设计原则：</p><ol><li>代理类和委托类具有相似的行为。（父类或者负接口）</li><li>代理类增强委托类。</li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ol><li>目标角色固定</li><li>应用程序执行前就得到目标角色</li><li>代理对象增强目标的行为</li><li>有可能存在多个代理，引发爆炸。</li></ol><p>自己手写。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>根据反射机制，在运行时动态产生。增强目标对象的行为。目标对象不固定。</p><ol><li>JDK动态代理</li><li>CGL动态代理</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>必须有接口实现。委托给代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Proxy代理类中的静态方法newProxyInstance()有三个参数</span></span><br><span class="line"><span class="comment">//类加载器</span></span><br><span class="line"><span class="comment">//代理对象接口</span></span><br><span class="line"><span class="comment">//一个InvocationHandler接口</span></span><br><span class="line"><span class="comment">//返回一个指定接口的代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdkProxy</span></span>&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object taget;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">jdkProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过调用Proxy的newProxyInstance()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLiader loader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 没有目标对象，就不能通过jdk动态代理</span></span><br><span class="line">        Class[] interfaces = target.getClas().getInterfaces();</span><br><span class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="comment">//当代理对象调用方法时，invoke会被执行一次</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"test"</span>);</span><br><span class="line">            <span class="comment">//通过反射中的 invoke方法调用指定对象的指定方法</span></span><br><span class="line">            <span class="comment">//调用target的mthod方法。args参数</span></span><br><span class="line">            Object reuslt = method.invoke(target,args);</span><br><span class="line">            <span class="comment">//方法的返回值</span></span><br><span class="line">            <span class="keyword">return</span> result；</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">        Object object  = Proxy.newProxyInstance(loader,interfaces,invocationHandler);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starte</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//得到目标对象</span></span><br><span class="line">        Student student  = <span class="keyword">new</span> Student();<span class="comment">//Student 实现了 Person接口。</span></span><br><span class="line">        <span class="comment">// 得到代理类</span></span><br><span class="line">        jdkProxy proxy = <span class="keyword">new</span> jdkProxy(student);</span><br><span class="line">        <span class="comment">//得到代理对象</span></span><br><span class="line">        Student object = (Student) jdkProxy.getProxy();</span><br><span class="line">        object.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK只能代理实现了接口的类，CGLIB对指定的目标类生成一个子类，覆盖里面的方法。采用继承，父类不能用final修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 定义方法拦截器</span></span><br><span class="line">        MethodInterceptor methodInterceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置代理过程</span></span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line">        <span class="comment">//生成一个类</span></span><br><span class="line">        <span class="keyword">return</span>  enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starte</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//得到目标对象</span></span><br><span class="line">        Student student  = <span class="keyword">new</span> Student();<span class="comment">//Student 继承了Person类。</span></span><br><span class="line">        <span class="comment">// 得到代理类</span></span><br><span class="line">        jdkProxy proxy = <span class="keyword">new</span> CglibProxy(student);</span><br><span class="line">        <span class="comment">//得到代理对象</span></span><br><span class="line">        Student object = (Student) CglibProxy.getProxy();</span><br><span class="line">        object.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;Java基础回顾&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="语言基础" scheme="https://heugzh.github.io/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://heugzh.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>高精度</title>
    <link href="https://heugzh.github.io/2021/07/03/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>https://heugzh.github.io/2021/07/03/%E9%AB%98%E7%B2%BE%E5%BA%A6/</id>
    <published>2021-07-03T15:16:15.000Z</published>
    <updated>2021-07-03T15:18:50.298Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>高精度算法</strong></div><a id="more"></a><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><blockquote><p>高精度是用于处理大数据的计算。当一个加、减、乘、除运算中出现几百位的数据时，该数据超出了C++基本数据类型所能表示的范围，所以也就不能直接进行运算（Python可以直接运算的）。可以将数据的每一位放入一个数组中，通过数组来模拟每一位的运算，这就是高精度算法。</p></blockquote><h2 id="高精度模板"><a href="#高精度模板" class="headerlink" title="高精度模板"></a>高精度模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//用于存放其中一个输入</span></span><br><span class="line"><span class="keyword">int</span>  b[<span class="number">5000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//用于存放另一个输入</span></span><br><span class="line"><span class="keyword">int</span>  c[<span class="number">10000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存放结果</span></span><br><span class="line"><span class="keyword">int</span> lena=<span class="number">0</span>; <span class="comment">// 第一个数的位数</span></span><br><span class="line"><span class="keyword">int</span> lenb=<span class="number">0</span>; <span class="comment">// 第二个数的位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)&#123;</span><br><span class="line">            c[i] = a[i] + b[j];</span><br><span class="line">        c[i+<span class="number">1</span>] += c[i]/<span class="number">10</span>;</span><br><span class="line">        c[i] = c[i] %<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span>(c[i]==<span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>) i--;</span><br><span class="line">    <span class="comment">// 输出数值</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;c[i--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenb;j++)&#123;</span><br><span class="line">c[i+j]+=a[i]*b[j];</span><br><span class="line">c[i+j+<span class="number">1</span>]+=c[i+j]/<span class="number">10</span>;</span><br><span class="line">c[i+j]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i=lena+lenb;</span><br><span class="line">    <span class="comment">//考虑输出会出现很多前导0.</span></span><br><span class="line">    <span class="comment">//还有输出就是0的情况。所以while的判断条件是 i&gt;0。</span></span><br><span class="line"><span class="keyword">while</span>(c[i]==<span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>) i--;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;c[i--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s; <span class="comment">//按字符串读入第一个数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">a[lena++] = s[i]-<span class="string">'0'</span>;  <span class="comment">//倒序存放到数组,方便进位。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s; <span class="comment">//读入第二个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">b[lenb++] = s[i]-<span class="string">'0'</span>;<span class="comment">//倒序存放到数组  </span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    add()</span><br><span class="line">    mul()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压位"><a href="#压位" class="headerlink" title="压位"></a>压位</h2><p>优化空间：压位，一个int类型空间只放一个一位数太浪费了。</p><p>一次存放4位，也就是压4位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2510</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//用于存放其中一个输入</span></span><br><span class="line"><span class="keyword">int</span>  b[<span class="number">2510</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//用于存放另一个输入</span></span><br><span class="line"><span class="keyword">int</span>  c[<span class="number">2510</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存放结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s; <span class="comment">//按字符串读入第一个数字</span></span><br><span class="line"><span class="keyword">int</span> lena=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,w=<span class="number">1</span>;i&lt;s.length();++i,w=w*<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>)&#123; w= <span class="number">1</span>;++lena;&#125;</span><br><span class="line">a[lena<span class="number">-1</span>] += w*(s[s.length()<span class="number">-1</span>-i]-<span class="string">'0'</span>);  <span class="comment">//倒序存放到数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s; <span class="comment">//读入第二个字符串</span></span><br><span class="line"><span class="keyword">int</span> lenb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,w=<span class="number">1</span>;i&lt;s.length();++i,w=w*<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>)&#123; w= <span class="number">1</span>;++lenb;&#125;</span><br><span class="line">b[lenb<span class="number">-1</span>] += w*(s[s.length()<span class="number">-1</span>-i]-<span class="string">'0'</span>);  <span class="comment">//倒序存放到数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘法运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenb;j++)&#123;</span><br><span class="line">c[i+j]+=a[i]*b[j];  <span class="comment">//乘法结果不能超过int类型的范围。</span></span><br><span class="line">c[i+j+<span class="number">1</span>]+=c[i+j]/<span class="number">10000</span>;</span><br><span class="line">c[i+j]%=<span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i=lena+lenb;</span><br><span class="line"><span class="keyword">while</span>(c[i]==<span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>) i--;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c[i--];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%04d"</span>,c[i--]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，压位的位数不能太大，如果是int类型，由于其中有乘法，其结果不能超过int的范围。</p><p>一般而言：乘除压4位，加减压9位。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;高精度算法&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度" scheme="https://heugzh.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://heugzh.github.io/2021/07/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://heugzh.github.io/2021/07/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-07-01T11:51:32.000Z</published>
    <updated>2021-07-02T14:54:04.447Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>基础算法——二分查找</strong></div><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>二分查找算法在算法题目中一个是<strong>查找数组中符合某个一个条件的值</strong>。另一个应用就是<strong>二分答案</strong>。对于某些算法题目给出了答案的范围。此时可以通过二分查找，不断的缩小答案的范围，直到最后符合条件的最大值或最小值。</p></blockquote><h2 id="算法模板一"><a href="#算法模板一" class="headerlink" title="算法模板一"></a>算法模板一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 此处使用left + (right-left)/2，而不是(left+right)/2，防止其和超过了int的取值范围。</span></span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此处的搜索空间是 <strong>[ left , right ]</strong> 的闭区间，所以while之中的条件必须是有 <strong>=</strong> 。否则对于最后的 <strong>left = right</strong> 的节点没有被搜索到。只有 <strong>left&gt;right</strong> ，搜索空间才为空。</p><h1 id="算法模板二（寻找左侧边界）"><a href="#算法模板二（寻找左侧边界）" class="headerlink" title="算法模板二（寻找左侧边界）"></a>算法模板二（寻找左侧边界）</h1><p>算法模板一对于数组[1,2,2,2,3] target=2。其返回的索引就是2，但是如果想获得target的左边界，算法模板一就无法处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">           right = mid  <span class="comment">// </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">    <span class="comment">// 返回值的最左边界值。返回的是大于等于target的值的最近位置。</span></span><br><span class="line">    <span class="comment">//也可以理解为数组中有left个元素比target小。</span></span><br><span class="line">    <span class="comment">// 如果是要找到target，只需要一个判断。</span></span><br><span class="line">    <span class="comment">// return target==nums[left] ? left-1 : -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法模板二的搜索空间是 <strong>[ left ，right )</strong> 。每次判断完中间值后，如果中间值大于等于target，则更新搜索空间为 <strong>[ left ，mid)</strong> 。否则就更新为 <strong>[mid+1，right)</strong> 。循环终结的条件是left == right，此时搜索空间为空。</p><h2 id="算法模板三（寻找右侧边界）"><a href="#算法模板三（寻找右侧边界）" class="headerlink" title="算法模板三（寻找右侧边界）"></a>算法模板三（寻找右侧边界）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">           left = mid+<span class="number">1</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">// 返回值的最右边界值。返回的是小于等于target的值的最近位置。</span></span><br><span class="line">    <span class="comment">// 如果是要找到target，只需要一个判断。</span></span><br><span class="line">    <span class="comment">// if(left ==0)</span></span><br><span class="line">    <span class="comment">//return -1;</span></span><br><span class="line">    <span class="comment">// return target==nums[left-1] ? left-1 : -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法模板三的搜索空间是 <strong>[ left ，right )</strong> 。每次判断完中间值后，如果中间值小于等于target，则更新搜索空间为 <strong>[mid+1，right)</strong> 。否则就更新为 <strong>[ left，right )</strong> 。循环终结的条件是left == right，此时搜索空间为空。</p><h2 id="二分答案的模板"><a href="#二分答案的模板" class="headerlink" title="二分答案的模板"></a>二分答案的模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// check 函数是看该答案是否满足条件。</span></span><br><span class="line">        <span class="keyword">if</span>( check(mid) )</span><br><span class="line">           left = mid <span class="comment">// left 是符合条件的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;基础算法——二分查找&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="https://heugzh.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://heugzh.github.io/2021/07/01/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://heugzh.github.io/2021/07/01/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2021-07-01T09:58:23.000Z</published>
    <updated>2021-07-02T14:49:02.446Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>markdown基础语法</strong></div><a id="more"></a><h1 id="Markdown-语法自查"><a href="#Markdown-语法自查" class="headerlink" title="Markdown 语法自查"></a>Markdown 语法自查</h1><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p># 代表标题级别，级别数越小，字体越大</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*倾斜*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line">加粗最好在*号前面和后面加入空格，不然同一行中有多个加粗会出现问题。</span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：</p><p><em>倾斜</em><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 此处是引用</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>此处是引用</p></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="emphasis">***</span>*</span><br></pre></td></tr></table></figure><hr><hr><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名</span>](<span class="link">链接地址 "title"</span>)</span><br><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 "title"</span>)</span><br><span class="line">title是当鼠标放在其上的显示文字。</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https;//baidu.com" title="百度链接">百度</a></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">- </span>列表内容1</span><br><span class="line"><span class="bullet">+ </span>列表内容1</span><br><span class="line"><span class="bullet">* </span>列表内容3</span><br><span class="line">有序列表：</span><br><span class="line"><span class="bullet">1. </span>列表内容1</span><br><span class="line"><span class="bullet">2. </span>列表内容1</span><br><span class="line"><span class="bullet">3. </span>列表内容3</span><br><span class="line">嵌套列表，前一级空3个空格。</span><br><span class="line"><span class="bullet">1. </span>列表1</span><br><span class="line">   1.1 列表1-1</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>列表内容1</li></ul><ul><li>列表内容1</li></ul><ul><li>列表内容3</li></ul><ol><li>列表内容1</li><li>列表内容1</li><li>列表内容3</li></ol><ol><li>列表1<br> 1.1 列表1-1</li></ol><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行代码</span><br><span class="line"><span class="code">`代码`</span></span><br><span class="line"></span><br><span class="line">多行代码 使用两个<span class="code">```</span>将代码块包起来</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>markdown语法支持很多的html的标签。可以使用html标签来优化界面。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;markdown基础语法&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="tools" scheme="https://heugzh.github.io/categories/tools/"/>
    
    
    <category term="markdown" scheme="https://heugzh.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://heugzh.github.io/2021/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://heugzh.github.io/2021/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-06-29T14:09:24.000Z</published>
    <updated>2021-07-01T09:02:07.074Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>计算机网络概述</strong></div><a id="more"></a><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>计算机网路是一些互联的、自治的计算机系统的集合。</li><li>将一个分散的、具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现<code>资源的共享和信息传递</code>的系统。是互连的、自治的计算机集合。</li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>从组成成分上看，主要由硬件、软件、和协议组成，缺一不可。其中协议是其核心，定义了网络数据传输时所需要遵循的规范。</li><li>从工作方式上看，分为边缘部分和核心部分。边缘部分就是用户的主机，用于进行通信和资源共享。其核心部分由大量网络及路由器组成，它为边缘部分提供连通性和交换服务。</li><li>从功能上看，分为通信子网和资源子网。通信子网由各种协议和传输介质，通信设备组成。</li></ol><h3 id="计网功能"><a href="#计网功能" class="headerlink" title="计网功能"></a>计网功能</h3><ol><li><p>数据通信</p><p> 计网最基本、最重要的功能。实现信息传输。</p></li><li><p>资源共享</p><p> 软件、数据、硬件共享。提高硬件资源、软件资源、数据资源的利用率。</p></li><li><p>分布式处理</p></li><li><p>提高可靠性：计网中的各个计算机可以通过网络互为代替机。</p></li><li><p>负载均衡。</p></li></ol><h3 id="计网分类"><a href="#计网分类" class="headerlink" title="计网分类"></a>计网分类</h3><ol><li><p>按范围分：广域网（交换技术）、城域网（以太网技术）、局域网（广播技术）、个人区域网（无线技术）。</p></li><li><p>按传输技术分类：广播式、点对点网络。</p></li><li><p>按拓扑结构分类：总线形（局域网）、星形、环形和网状（广域网）。</p></li><li><p>按照交换技术分类： 电路交换网络、报文交换网络（封装为一个报文）、分组交换网络（数据拆分为多个数据包）。</p></li></ol><h3 id="计算机标准化工作"><a href="#计算机标准化工作" class="headerlink" title="计算机标准化工作"></a>计算机标准化工作</h3><p>RFC（Request For Comments）</p><p>因特网草案 -&gt; 建议标准（形成RFC文档）-&gt;草案标准 -&gt;因特网标准。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ol><li><p>带宽：网络通信线路所能传送数据的能力。单位b/s。</p></li><li><p>时延：从网络的一端发送到另外另一端所花费的时间。分为发送时延、传播时延、处理时延、排队时延。</p><p> 发送时延（传输时延）：从分组的第一个比特算起， 到最后一个比特发送完毕的时间。 发送时延 = 分组长度/信道的宽度。</p><p> 传播时延：电磁波在信道之中的传输时间。传播时延 = 信道长度/电磁波在信道上的传播速率。</p><p> 排队和处理时延一般是可忽略。</p><p> <strong>高速链路提高的是发送速率，而非传播速率。减少的是发送时延。</strong></p></li><li><p>时延带宽积： 指发送端的第一个比特即将到达终点时，发送端发送了多少的比特数据。时延带宽积 = 传播时</p></li><li><p>延 * 信道带宽。</p></li><li><p>往返时延（RTT）从发送端发送数据开始，到发送端收到接收端的确认。 </p></li><li><p>吞吐量： 单位时间内通过某个网络的数据量，受到带宽和网络额定速率的限制。</p></li><li><p>信道利用率：有数据通过的是时间 / 无数据通过的时间。</p></li></ol><h2 id="网络体系结构和参考模型"><a href="#网络体系结构和参考模型" class="headerlink" title="网络体系结构和参考模型"></a>网络体系结构和参考模型</h2><p>网络的体系结构是计算机网络的各层以及其协议的集合。</p><p>分层结构:从低到高为1，2，3…层</p><p>协议、接口、服务<br>ISO/OSI模型（5层）<br>TCP/IP 模型（7层）</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;计算机网络概述&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://heugzh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://heugzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="考研" scheme="https://heugzh.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-05-18T14:51:12.000Z</published>
    <updated>2021-06-28T09:12:28.610Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>并查集算法的基本概念</strong></div><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>并查集主要用于解决一些元素分组的问题，它管理一系列的<strong>不相交</strong>的集合。并且支持两种操作：</p><ul><li>合并（Union）：把两个集合合并成一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合。</li></ul></blockquote><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认初始状态每个结点都为根结点。</p><p><strong>查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( fa[x]==x )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层层访问其父节点，直到根节点。判断两个元素是否是属于同一个集合，只需要看他们的根节点是否相同。</p><p><strong>合并</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> fi,<span class="keyword">int</span> se)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(fi)] = <span class="built_in">find</span>(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第一个集合的根结点挂载到第二个集合根节点。</p><p>上述的简单合并效率是很低的，尤其在出现了很长的链的情况下，访问根节点会需要很长的时间。最重要的是大部分题目使用上述方法会超时，所以需要优化其代码。</p><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>可以采用路径压缩的方式，集合合并的时候我们只关心根节点而不关心中间的遍历过程。那么我们可以在查询的时候将路径上的每个节点的父节点都改为根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>[fa[x]];</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者简写为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x== fa[x] ? x  :( fa[x]=<span class="built_in">find</span>(fa[x]) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>经过路径压缩之后的并查集并不是一个只有两层的树，因为路径压缩只是在查询的时候进行，并且也只是压缩了其中一条路径。所以很多时候其结果仍然很复杂。当两颗树合并时，如果把简单的树往复杂的树上合并，最后的结果相对更简单。</p><p>所以有了一种新的优化策略，即按秩合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt;= rank[y] )</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">   <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x!=y )</span><br><span class="line">       rank[y]++; <span class="comment">// 深度相同，挂载后树的高度加一。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然懂了原理，还需要实践。可以去<a href="https://www.luogu.com.cn/">落谷</a>或者<a href="https://leetcode-cn.com/">leetcode</a>刷刷题。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;并查集算法的基本概念&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置</title>
    <link href="https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/"/>
    <id>https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/</id>
    <published>2021-05-16T06:32:21.000Z</published>
    <updated>2021-07-01T09:01:04.730Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong>重新布置博客主题</strong></div><a id="more"></a><h1 id="安装所需环境"><a href="#安装所需环境" class="headerlink" title="安装所需环境"></a>安装所需环境</h1><p>首先需要安装git以及node.js。直接去对应的官网下载就好。git版本无所谓，但是node.js的版本就很重要。大部分博客主题是基于node.js v14之前的写的（node v14似乎做了一次大改），所以如果版本不匹配，会发生一些问题（错误会在本篇最后具体描述）。所以最好安装node.js v14之前的版本。</p><h1 id="hexo主题配置"><a href="#hexo主题配置" class="headerlink" title="hexo主题配置"></a>hexo主题配置</h1><p>首先使用 npm 安装 hexo-cli 。</p><p><code> npm install hexo-cli -g</code></p><p>然后找一个空的文件夹 执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后访问localhost:4000, 就能看到默认的一个hexo主题。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>默认主题说实话，太丑了。得换。</p><p>可以在 <a href="https://hexo.io/themes/"> hexo官网 </a>找一个好康的主题。</p><p>首先，下载主题。我使用的是indigo主题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git</span><br></pre></td></tr></table></figure><p>然后把下载的文件夹放到<code>blog/themes</code>。</p><p>接下来，更新hexo 的版本。hexo v5也是大改过的版本。至少indigo主题不支持hexo v5。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo@4.0.0</span><br></pre></td></tr></table></figure><p>安装 indigo所需依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-less --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure><p>修改blog 下的<code>_config</code>文件，修改theme 为 hexo-theme-indigo。</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以在本地 localhost:4000 看到新的主题。</p><h1 id="谈谈问题"><a href="#谈谈问题" class="headerlink" title="谈谈问题"></a>谈谈问题</h1><p>版本匹配真的是一个坑，indigo主题只是说了使用hexo v3.0+ 和node v6.0+。然后下载的时候下载最新版本的hexo和node会直接g掉。</p><h2 id="node版本不匹配会遇到的问题"><a href="#node版本不匹配会遇到的问题" class="headerlink" title="node版本不匹配会遇到的问题"></a>node版本不匹配会遇到的问题</h2><p>node 版本如果是14以上的话，执行<code>hexo s</code>命令是没有问题的。<code>hexo g</code> 本来是应该将markdown文章解析之后放入public文件夹。事实是，public里面的<code>index.html</code> 是一个空白文件。<code> hexo s</code>能显示正常。但是当<code>hexo  d</code>(该命令用于部署到网上)，执行的时候是把public里面的文件给提交上去。</p><h2 id="hexo版本不匹配所遇到的问题"><a href="#hexo版本不匹配所遇到的问题" class="headerlink" title="hexo版本不匹配所遇到的问题"></a>hexo版本不匹配所遇到的问题</h2><p>由于hexo v5.0 将<code>lodash</code>从全局变量中移除。 所以<code> hexo g</code> 执行的时候会出现大量的 <code>_</code>未定义。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong&gt;重新布置博客主题&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="博客配置" scheme="https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="https://heugzh.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
