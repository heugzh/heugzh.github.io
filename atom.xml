<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深海的鲸的鱼塘</title>
  
  <subtitle>为何而愁？</subtitle>
  <link href="https://heugzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://heugzh.github.io/"/>
  <updated>2021-07-02T14:28:50.033Z</updated>
  <id>https://heugzh.github.io/</id>
  
  <author>
    <name>深海的鲸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找.md</title>
    <link href="https://heugzh.github.io/2021/07/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://heugzh.github.io/2021/07/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-07-01T11:51:32.000Z</published>
    <updated>2021-07-02T14:28:50.033Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >基础算法——二分查找</strong></div><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>二分查找算法在算法题目中一个是<strong>查找数组中符合某个一个条件的值</strong>。另一个应用就是<strong>二分答案</strong>。对于某些算法题目给出了答案的范围。此时可以通过二分查找，不断的缩小答案的范围，直到最后符合条件的最大值或最小值。</p></blockquote><h2 id="算法模板一"><a href="#算法模板一" class="headerlink" title="算法模板一"></a>算法模板一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 此处使用left + (right-left)/2，而不是(left+right)/2，防止其和超过了int的取值范围。</span></span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的搜索空间是**[ left , right ]<strong>的闭区间，所以while之中的条件必须是有</strong>=<strong>。否则对于最后的 <strong>left = right</strong> 的节点没有被搜索到。只有</strong>left&gt;right** ，搜索空间才为空。</p><h1 id="算法模板二（寻找左侧边界）"><a href="#算法模板二（寻找左侧边界）" class="headerlink" title="算法模板二（寻找左侧边界）"></a>算法模板二（寻找左侧边界）</h1><p>算法模板一对于数组[1,2,2,2,3] target=2。其返回的索引就是2，但是如果想获得target的左边界，算法模板一就无法处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">           right = mid  <span class="comment">// </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">    <span class="comment">// 返回值的最左边界值。返回的是大于等于target的值的最近位置。也可以理解为数组中有left个元素比target小。</span></span><br><span class="line">    <span class="comment">// 如果是要找到target，只需要一个判断。</span></span><br><span class="line">    <span class="comment">// return target==nums[left] ? left-1 : -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法模板二的搜索空间是**[ left ，right ）<strong>。每次判断完中间值后，如果中间值大于等于target，则更新搜索空间为</strong>[ left ，mid）<strong>。否则就更新为</strong>[mid+1，right)**。循环终结的条件是left == right，此时搜索空间为空。</p><h2 id="算法模板三（寻找右侧边界）"><a href="#算法模板三（寻找右侧边界）" class="headerlink" title="算法模板三（寻找右侧边界）"></a>算法模板三（寻找右侧边界）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">           left = mid+<span class="number">1</span> <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">// 返回值的最右边界值。返回的是小于等于target的值的最近位置。</span></span><br><span class="line">    <span class="comment">// 如果是要找到target，只需要一个判断。</span></span><br><span class="line">    <span class="comment">// if(left ==0)</span></span><br><span class="line">    <span class="comment">//return -1;</span></span><br><span class="line">    <span class="comment">// return target==nums[left-1] ? left-1 : -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法模板三的搜索空间是**[ left ，right ）<strong>。每次判断完中间值后，如果中间值小于等于target，则更新搜索空间为</strong>[mid+1，right)<strong>。否则就更新为</strong>[ left，right ）**。循环终结的条件是left == right，此时搜索空间为空。</p><h2 id="二分答案的模板"><a href="#二分答案的模板" class="headerlink" title="二分答案的模板"></a>二分答案的模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&amp;nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// check 函数是看该答案是否满足条件。</span></span><br><span class="line">        <span class="keyword">if</span>( check(mid) )</span><br><span class="line">           left = mid <span class="comment">// left 是符合条件的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;基础算法——二分查找&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二分查找" scheme="https://heugzh.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://heugzh.github.io/2021/07/01/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://heugzh.github.io/2021/07/01/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2021-07-01T09:58:23.000Z</published>
    <updated>2021-07-02T14:30:29.783Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >markdown基础语法</strong></div><a id="more"></a><h1 id="Markdown-语法自查"><a href="#Markdown-语法自查" class="headerlink" title="Markdown 语法自查"></a>Markdown 语法自查</h1><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p># 代表标题级别，级别数越小，字体越大</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*倾斜*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：</p><p><em>倾斜</em><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 此处是引用</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>此处是引用</p></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="emphasis">***</span>*</span><br></pre></td></tr></table></figure><hr><hr><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名</span>](<span class="link">链接地址 "title"</span>)</span><br><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 "title"</span>)</span><br><span class="line">title是当鼠标放在其上的显示文字。</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="https;//baidu.com" title="百度链接">百度</a></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无序列表：</span><br><span class="line"><span class="bullet">- </span>列表内容1</span><br><span class="line"><span class="bullet">+ </span>列表内容1</span><br><span class="line"><span class="bullet">* </span>列表内容3</span><br><span class="line">有序列表：</span><br><span class="line"><span class="bullet">1. </span>列表内容1</span><br><span class="line"><span class="bullet">2. </span>列表内容1</span><br><span class="line"><span class="bullet">3. </span>列表内容3</span><br><span class="line">嵌套列表，前一级空3个空格。</span><br><span class="line"><span class="bullet">1. </span>列表1</span><br><span class="line">   1.1 列表1-1</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>列表内容1</li></ul><ul><li>列表内容1</li></ul><ul><li>列表内容3</li></ul><ol><li>列表内容1</li><li>列表内容1</li><li>列表内容3</li></ol><ol><li>列表1<br> 1.1 列表1-1</li></ol><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单行代码</span><br><span class="line"><span class="code">`代码`</span></span><br><span class="line"></span><br><span class="line">多行代码 使用两个<span class="code">```</span>将代码块包起来</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>markdown语法支持很多的html的标签。可以使用html标签来优化界面。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;markdown基础语法&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="tools" scheme="https://heugzh.github.io/categories/tools/"/>
    
    
    <category term="markdown" scheme="https://heugzh.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://heugzh.github.io/2021/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://heugzh.github.io/2021/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-06-29T14:09:24.000Z</published>
    <updated>2021-07-01T09:02:07.074Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >计算机网络概述</strong></div><a id="more"></a><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>计算机网路是一些互联的、自治的计算机系统的集合。</li><li>将一个分散的、具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现<code>资源的共享和信息传递</code>的系统。是互连的、自治的计算机集合。</li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>从组成成分上看，主要由硬件、软件、和协议组成，缺一不可。其中协议是其核心，定义了网络数据传输时所需要遵循的规范。</li><li>从工作方式上看，分为边缘部分和核心部分。边缘部分就是用户的主机，用于进行通信和资源共享。其核心部分由大量网络及路由器组成，它为边缘部分提供连通性和交换服务。</li><li>从功能上看，分为通信子网和资源子网。通信子网由各种协议和传输介质，通信设备组成。</li></ol><h3 id="计网功能"><a href="#计网功能" class="headerlink" title="计网功能"></a>计网功能</h3><ol><li><p>数据通信</p><p> 计网最基本、最重要的功能。实现信息传输。</p></li><li><p>资源共享</p><p> 软件、数据、硬件共享。提高硬件资源、软件资源、数据资源的利用率。</p></li><li><p>分布式处理</p></li><li><p>提高可靠性：计网中的各个计算机可以通过网络互为代替机。</p></li><li><p>负载均衡。</p></li></ol><h3 id="计网分类"><a href="#计网分类" class="headerlink" title="计网分类"></a>计网分类</h3><ol><li><p>按范围分：广域网（交换技术）、城域网（以太网技术）、局域网（广播技术）、个人区域网（无线技术）。</p></li><li><p>按传输技术分类：广播式、点对点网络。</p></li><li><p>按拓扑结构分类：总线形（局域网）、星形、环形和网状（广域网）。</p></li><li><p>按照交换技术分类： 电路交换网络、报文交换网络（封装为一个报文）、分组交换网络（数据拆分为多个数据包）。</p></li></ol><h3 id="计算机标准化工作"><a href="#计算机标准化工作" class="headerlink" title="计算机标准化工作"></a>计算机标准化工作</h3><p>RFC（Request For Comments）</p><p>因特网草案 -&gt; 建议标准（形成RFC文档）-&gt;草案标准 -&gt;因特网标准。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ol><li><p>带宽：网络通信线路所能传送数据的能力。单位b/s。</p></li><li><p>时延：从网络的一端发送到另外另一端所花费的时间。分为发送时延、传播时延、处理时延、排队时延。</p><p> 发送时延（传输时延）：从分组的第一个比特算起， 到最后一个比特发送完毕的时间。 发送时延 = 分组长度/信道的宽度。</p><p> 传播时延：电磁波在信道之中的传输时间。传播时延 = 信道长度/电磁波在信道上的传播速率。</p><p> 排队和处理时延一般是可忽略。</p><p> <strong>高速链路提高的是发送速率，而非传播速率。减少的是发送时延。</strong></p></li><li><p>时延带宽积： 指发送端的第一个比特即将到达终点时，发送端发送了多少的比特数据。时延带宽积 = 传播时</p></li><li><p>延 * 信道带宽。</p></li><li><p>往返时延（RTT）从发送端发送数据开始，到发送端收到接收端的确认。 </p></li><li><p>吞吐量： 单位时间内通过某个网络的数据量，受到带宽和网络额定速率的限制。</p></li><li><p>信道利用率：有数据通过的是时间 / 无数据通过的时间。</p></li></ol><h2 id="网络体系结构和参考模型"><a href="#网络体系结构和参考模型" class="headerlink" title="网络体系结构和参考模型"></a>网络体系结构和参考模型</h2><p>网络的体系结构是计算机网络的各层以及其协议的集合。</p><p>分层结构:从低到高为1，2，3…层</p><p>协议、接口、服务<br>ISO/OSI模型（5层）<br>TCP/IP 模型（7层）</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;计算机网络概述&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://heugzh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://heugzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="考研" scheme="https://heugzh.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-05-18T14:51:12.000Z</published>
    <updated>2021-06-28T09:12:28.610Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >并查集算法的基本概念</strong></div><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>并查集主要用于解决一些元素分组的问题，它管理一系列的<strong>不相交</strong>的集合。并且支持两种操作：</p><ul><li>合并（Union）：把两个集合合并成一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合。</li></ul></blockquote><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认初始状态每个结点都为根结点。</p><p><strong>查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( fa[x]==x )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层层访问其父节点，直到根节点。判断两个元素是否是属于同一个集合，只需要看他们的根节点是否相同。</p><p><strong>合并</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> fi,<span class="keyword">int</span> se)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(fi)] = <span class="built_in">find</span>(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第一个集合的根结点挂载到第二个集合根节点。</p><p>上述的简单合并效率是很低的，尤其在出现了很长的链的情况下，访问根节点会需要很长的时间。最重要的是大部分题目使用上述方法会超时，所以需要优化其代码。</p><h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>可以采用路径压缩的方式，集合合并的时候我们只关心根节点而不关心中间的遍历过程。那么我们可以在查询的时候将路径上的每个节点的父节点都改为根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>[fa[x]];</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者简写为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x== fa[x] ? x  :( fa[x]=<span class="built_in">find</span>(fa[x]) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>经过路径压缩之后的并查集并不是一个只有两层的树，因为路径压缩只是在查询的时候进行，并且也只是压缩了其中一条路径。所以很多时候其结果仍然很复杂。当两颗树合并时，如果把简单的树往复杂的树上合并，最后的结果相对更简单。</p><p>所以有了一种新的优化策略，即按秩合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(i),y=<span class="built_in">find</span>(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt;= rank[y] )</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">   <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x!=y )</span><br><span class="line">       rank[y]++; <span class="comment">// 深度相同，挂载后树的高度加一。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然懂了原理，还需要实践。可以去<a href="https://www.luogu.com.cn/">落谷</a>或者<a href="https://leetcode-cn.com/">leetcode</a>刷刷题。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;并查集算法的基本概念&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法" scheme="https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置</title>
    <link href="https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/"/>
    <id>https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/</id>
    <published>2021-05-16T06:32:21.000Z</published>
    <updated>2021-07-01T09:01:04.730Z</updated>
    
    <content type="html"><![CDATA[<div align="left"> <strong >重新布置博客主题</strong></div><a id="more"></a><h1 id="安装所需环境"><a href="#安装所需环境" class="headerlink" title="安装所需环境"></a>安装所需环境</h1><p>首先需要安装git以及node.js。直接去对应的官网下载就好。git版本无所谓，但是node.js的版本就很重要。大部分博客主题是基于node.js v14之前的写的（node v14似乎做了一次大改），所以如果版本不匹配，会发生一些问题（错误会在本篇最后具体描述）。所以最好安装node.js v14之前的版本。</p><h1 id="hexo主题配置"><a href="#hexo主题配置" class="headerlink" title="hexo主题配置"></a>hexo主题配置</h1><p>首先使用 npm 安装 hexo-cli 。</p><p><code> npm install hexo-cli -g</code></p><p>然后找一个空的文件夹 执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后访问localhost:4000, 就能看到默认的一个hexo主题。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>默认主题说实话，太丑了。得换。</p><p>可以在 <a href="https://hexo.io/themes/"> hexo官网 </a>找一个好康的主题。</p><p>首先，下载主题。我使用的是indigo主题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git</span><br></pre></td></tr></table></figure><p>然后把下载的文件夹放到<code>blog/themes</code>。</p><p>接下来，更新hexo 的版本。hexo v5也是大改过的版本。至少indigo主题不支持hexo v5。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo@4.0.0</span><br></pre></td></tr></table></figure><p>安装 indigo所需依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-less --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure><p>修改blog 下的<code>_config</code>文件，修改theme 为 hexo-theme-indigo。</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以在本地 localhost:4000 看到新的主题。</p><h1 id="谈谈问题"><a href="#谈谈问题" class="headerlink" title="谈谈问题"></a>谈谈问题</h1><p>版本匹配真的是一个坑，indigo主题只是说了使用hexo v3.0+ 和node v6.0+。然后下载的时候下载最新版本的hexo和node会直接g掉。</p><h2 id="node版本不匹配会遇到的问题"><a href="#node版本不匹配会遇到的问题" class="headerlink" title="node版本不匹配会遇到的问题"></a>node版本不匹配会遇到的问题</h2><p>node 版本如果是14以上的话，执行<code>hexo s</code>命令是没有问题的。<code>hexo g</code> 本来是应该将markdown文章解析之后放入public文件夹。事实是，public里面的<code>index.html</code> 是一个空白文件。<code> hexo s</code>能显示正常。但是当<code>hexo  d</code>(该命令用于部署到网上)，执行的时候是把public里面的文件给提交上去。</p><h2 id="hexo版本不匹配所遇到的问题"><a href="#hexo版本不匹配所遇到的问题" class="headerlink" title="hexo版本不匹配所遇到的问题"></a>hexo版本不匹配所遇到的问题</h2><p>由于hexo v5.0 将<code>lodash</code>从全局变量中移除。 所以<code> hexo g</code> 执行的时候会出现大量的 <code>_</code>未定义。</p>]]></content>
    
    
    <summary type="html">&lt;div align=&quot;left&quot;&gt; &lt;strong &gt;重新布置博客主题&lt;/strong&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="博客配置" scheme="https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="https://heugzh.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
