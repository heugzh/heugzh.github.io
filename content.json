{"meta":{"title":"深海的鲸的鱼塘","subtitle":"为何而愁？","description":"技术积累","author":"深海的鲸","url":"https://heugzh.github.io","root":"/"},"pages":[{"title":"about","date":"2021-05-26T08:35:41.000Z","updated":"2021-05-26T09:08:56.850Z","comments":true,"path":"about/index.html","permalink":"https://heugzh.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-16T06:30:32.000Z","updated":"2021-05-17T05:17:25.174Z","comments":true,"path":"categories/index.html","permalink":"https://heugzh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-15T05:19:04.000Z","updated":"2021-05-17T05:13:13.722Z","comments":true,"path":"tags/index.html","permalink":"https://heugzh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"高精度","slug":"高精度","date":"2021-07-03T15:16:15.000Z","updated":"2021-07-03T15:18:50.298Z","comments":true,"path":"2021/07/03/高精度/","link":"","permalink":"https://heugzh.github.io/2021/07/03/%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"高精度算法","text":"高精度算法 高精度 高精度是用于处理大数据的计算。当一个加、减、乘、除运算中出现几百位的数据时，该数据超出了C++基本数据类型所能表示的范围，所以也就不能直接进行运算（Python可以直接运算的）。可以将数据的每一位放入一个数组中，通过数组来模拟每一位的运算，这就是高精度算法。 高精度模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt; #include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[5000]=&#123;0&#125;;//用于存放其中一个输入int b[5000]=&#123;0&#125;;//用于存放另一个输入int c[10000]=&#123;0&#125;;//存放结果int lena=0; // 第一个数的位数int lenb=0; // 第二个数的位数// 加法运算void add()&#123; memset(c,0,sizeof(c)); for(int i=0;i&lt;lena;i++)&#123; c[i] = a[i] + b[j]; c[i+1] += c[i]/10; c[i] = c[i] %10; &#125; // 去掉前导0 while(c[i]==0&amp;&amp;i&gt;0) i--; // 输出数值 while(i&gt;=0) cout&lt;&lt;c[i--];&#125;//乘法运算void mul()&#123; memset(c,0,sizeof(c)); for(int i=0;i&lt;lena;i++) &#123; for(int j=0;j&lt;lenb;j++)&#123; c[i+j]+=a[i]*b[j]; c[i+j+1]+=c[i+j]/10; c[i+j]%=10; &#125; &#125; int i=lena+lenb; //考虑输出会出现很多前导0. //还有输出就是0的情况。所以while的判断条件是 i&gt;0。 while(c[i]==0&amp;&amp;i&gt;0) i--; while(i&gt;=0) cout&lt;&lt;c[i--];&#125;int main()&#123; string s; cin&gt;&gt;s; //按字符串读入第一个数字 for(int i=s.length()-1;i&gt;=0;i--)&#123; a[lena++] = s[i]-'0'; //倒序存放到数组,方便进位。 &#125; cin&gt;&gt;s; //读入第二个字符 for(int i=s.length()-1;i&gt;=0;i--)&#123; b[lenb++] = s[i]-'0';//倒序存放到数组 &#125; add() mul() return 0;&#125; 压位优化空间：压位，一个int类型空间只放一个一位数太浪费了。 一次存放4位，也就是压4位 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt; #include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[2510]=&#123;0&#125;;//用于存放其中一个输入int b[2510]=&#123;0&#125;;//用于存放另一个输入int c[2510]=&#123;0&#125;;//存放结果int main()&#123; string s; cin&gt;&gt;s; //按字符串读入第一个数字 int lena=0; for(int i=0,w=1;i&lt;s.length();++i,w=w*10)&#123; if(i%4==0)&#123; w= 1;++lena;&#125; a[lena-1] += w*(s[s.length()-1-i]-'0'); //倒序存放到数组 &#125; cin&gt;&gt;s; //读入第二个字符串 int lenb=0; for(int i=0,w=1;i&lt;s.length();++i,w=w*10)&#123; if(i%4==0)&#123; w= 1;++lenb;&#125; b[lenb-1] += w*(s[s.length()-1-i]-'0'); //倒序存放到数组 &#125; //乘法运算 for(int i=0;i&lt;lena;i++) &#123; for(int j=0;j&lt;lenb;j++)&#123; c[i+j]+=a[i]*b[j]; //乘法结果不能超过int类型的范围。 c[i+j+1]+=c[i+j]/10000; c[i+j]%=10000; &#125; &#125; int i=lena+lenb; while(c[i]==0&amp;&amp;i&gt;0) i--; cout&lt;&lt;c[i--]; while(i&gt;=0) printf(\"%04d\",c[i--]); return 0;&#125; 值得注意的是，压位的位数不能太大，如果是int类型，由于其中有乘法，其结果不能超过int的范围。 一般而言：乘除压4位，加减压9位。","categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://heugzh.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"二分查找","slug":"二分查找","date":"2021-07-01T11:51:32.000Z","updated":"2021-07-02T14:54:04.447Z","comments":true,"path":"2021/07/01/二分查找/","link":"","permalink":"https://heugzh.github.io/2021/07/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"基础算法——二分查找","text":"基础算法——二分查找 二分查找 二分查找算法在算法题目中一个是查找数组中符合某个一个条件的值。另一个应用就是二分答案。对于某些算法题目给出了答案的范围。此时可以通过二分查找，不断的缩小答案的范围，直到最后符合条件的最大值或最小值。 算法模板一12345678910111213141516int binarySearch(vector&lt;int &gt;&amp;nums,int target)&#123; if(nums.size()==0) return -1; int left=0,right=nums.size()-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; // 此处使用left + (right-left)/2，而不是(left+right)/2，防止其和超过了int的取值范围。 if(target==nums[mid]) return mid; else if(nums[mid]&lt;target) left = mid+1; else right = mid-1; &#125; return -1;&#125; 此处的搜索空间是 [ left , right ] 的闭区间，所以while之中的条件必须是有 = 。否则对于最后的 left = right 的节点没有被搜索到。只有 left&gt;right ，搜索空间才为空。 算法模板二（寻找左侧边界）算法模板一对于数组[1,2,2,2,3] target=2。其返回的索引就是2，但是如果想获得target的左边界，算法模板一就无法处理。 12345678910111213141516171819int binarySearch(vector&lt;int &gt;&amp;nums,int target)&#123; if(nums.size()==0) return -1; int left=0,right=nums.size(); while(left&lt;right)&#123; int mid = left + (right-left)/2; if(target==nums[mid]) right = mid // else if(nums[mid]&lt;target) left = mid+1; else right = mid; &#125; return left; // 返回值的最左边界值。返回的是大于等于target的值的最近位置。 //也可以理解为数组中有left个元素比target小。 // 如果是要找到target，只需要一个判断。 // return target==nums[left] ? left-1 : -1;&#125; 算法模板二的搜索空间是 [ left ，right ) 。每次判断完中间值后，如果中间值大于等于target，则更新搜索空间为 [ left ，mid) 。否则就更新为 [mid+1，right) 。循环终结的条件是left == right，此时搜索空间为空。 算法模板三（寻找右侧边界）1234567891011121314151617181920int binarySearch(vector&lt;int &gt;&amp;nums,int target)&#123; if(nums.size()==0) return -1; int left=0,right=nums.size(); while(left&lt;right)&#123; int mid = left + (right-left)/2; if(target==nums[mid]) left = mid+1 // else if(nums[mid]&lt;target) left = mid+1; else right = mid; &#125; return left -1; // 返回值的最右边界值。返回的是小于等于target的值的最近位置。 // 如果是要找到target，只需要一个判断。 // if(left ==0) // return -1; // return target==nums[left-1] ? left-1 : -1;&#125; 算法模板三的搜索空间是 [ left ，right ) 。每次判断完中间值后，如果中间值小于等于target，则更新搜索空间为 [mid+1，right) 。否则就更新为 [ left，right ) 。循环终结的条件是left == right，此时搜索空间为空。 二分答案的模板123456789101112int binarySearch(vector&lt;int &gt;&amp;nums,int target)&#123; int left=0,right=nums.size(); while(left&lt;right)&#123; int mid = left + (right-left)/2; // check 函数是看该答案是否满足条件。 if( check(mid) ) left = mid // left 是符合条件的 else right = mid-1; &#125; return left; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://heugzh.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2021-07-01T09:58:23.000Z","updated":"2021-07-02T14:49:02.446Z","comments":true,"path":"2021/07/01/markdown语法/","link":"","permalink":"https://heugzh.github.io/2021/07/01/markdown%E8%AF%AD%E6%B3%95/","excerpt":"markdown基础语法","text":"markdown基础语法 Markdown 语法自查标题# 代表标题级别，级别数越小，字体越大 123# 一级标题## 二级标题### 三级标题 字体12345*倾斜***加粗**加粗最好在*号前面和后面加入空格，不然同一行中有多个加粗会出现问题。***斜体加粗***~~删除线~~ 效果： 倾斜加粗斜体加粗删除线 引用1&gt; 此处是引用 效果： 此处是引用 分割线1234-------******* 链接123[链接名](链接地址 \"title\")![图片alt](图片地址 \"title\")title是当鼠标放在其上的显示文字。 效果： 百度 列表1234567891011无序列表：- 列表内容1+ 列表内容1* 列表内容3有序列表：1. 列表内容12. 列表内容13. 列表内容3嵌套列表，前一级空3个空格。1. 列表1 1.1 列表1-1 效果： 列表内容1 列表内容1 列表内容3 列表内容1 列表内容1 列表内容3 列表1 1.1 列表1-1 表格12345678表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容文字默认居左-两边加：表示文字居中-右边加：表示文字居右 表头 表头 表头 内容 内容 内容 内容 内容 内容 代码1234单行代码`代码`多行代码 使用两个```将代码块包起来 其它markdown语法支持很多的html的标签。可以使用html标签来优化界面。","categories":[{"name":"tools","slug":"tools","permalink":"https://heugzh.github.io/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://heugzh.github.io/tags/markdown/"}]},{"title":"计算机网络概述","slug":"计算机网络概述","date":"2021-06-29T14:09:24.000Z","updated":"2021-07-01T09:02:07.074Z","comments":true,"path":"2021/06/29/计算机网络概述/","link":"","permalink":"https://heugzh.github.io/2021/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","excerpt":"计算机网络概述","text":"计算机网络概述 计算机网络体系结构概念 计算机网路是一些互联的、自治的计算机系统的集合。 将一个分散的、具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源的共享和信息传递的系统。是互连的、自治的计算机集合。 组成 从组成成分上看，主要由硬件、软件、和协议组成，缺一不可。其中协议是其核心，定义了网络数据传输时所需要遵循的规范。 从工作方式上看，分为边缘部分和核心部分。边缘部分就是用户的主机，用于进行通信和资源共享。其核心部分由大量网络及路由器组成，它为边缘部分提供连通性和交换服务。 从功能上看，分为通信子网和资源子网。通信子网由各种协议和传输介质，通信设备组成。 计网功能 数据通信 计网最基本、最重要的功能。实现信息传输。 资源共享 软件、数据、硬件共享。提高硬件资源、软件资源、数据资源的利用率。 分布式处理 提高可靠性：计网中的各个计算机可以通过网络互为代替机。 负载均衡。 计网分类 按范围分：广域网（交换技术）、城域网（以太网技术）、局域网（广播技术）、个人区域网（无线技术）。 按传输技术分类：广播式、点对点网络。 按拓扑结构分类：总线形（局域网）、星形、环形和网状（广域网）。 按照交换技术分类： 电路交换网络、报文交换网络（封装为一个报文）、分组交换网络（数据拆分为多个数据包）。 计算机标准化工作RFC（Request For Comments） 因特网草案 -&gt; 建议标准（形成RFC文档）-&gt;草案标准 -&gt;因特网标准。 性能指标 带宽：网络通信线路所能传送数据的能力。单位b/s。 时延：从网络的一端发送到另外另一端所花费的时间。分为发送时延、传播时延、处理时延、排队时延。 发送时延（传输时延）：从分组的第一个比特算起， 到最后一个比特发送完毕的时间。 发送时延 = 分组长度/信道的宽度。 传播时延：电磁波在信道之中的传输时间。传播时延 = 信道长度/电磁波在信道上的传播速率。 排队和处理时延一般是可忽略。 高速链路提高的是发送速率，而非传播速率。减少的是发送时延。 时延带宽积： 指发送端的第一个比特即将到达终点时，发送端发送了多少的比特数据。时延带宽积 = 传播时 延 * 信道带宽。 往返时延（RTT）从发送端发送数据开始，到发送端收到接收端的确认。 吞吐量： 单位时间内通过某个网络的数据量，受到带宽和网络额定速率的限制。 信道利用率：有数据通过的是时间 / 无数据通过的时间。 网络体系结构和参考模型网络的体系结构是计算机网络的各层以及其协议的集合。 分层结构:从低到高为1，2，3…层 协议、接口、服务ISO/OSI模型（5层）TCP/IP 模型（7层）","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://heugzh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://heugzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"考研","slug":"考研","permalink":"https://heugzh.github.io/tags/%E8%80%83%E7%A0%94/"}]},{"title":"并查集","slug":"并查集","date":"2021-05-18T14:51:12.000Z","updated":"2021-06-28T09:12:28.610Z","comments":true,"path":"2021/05/18/并查集/","link":"","permalink":"https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"并查集算法的基本概念","text":"并查集算法的基本概念 并查集 并查集主要用于解决一些元素分组的问题，它管理一系列的不相交的集合。并且支持两种操作： 合并（Union）：把两个集合合并成一个集合。 查询（Find）：查询两个元素是否在同一个集合。 实现代码初始化 123456int fa[MAXN];inline void init(int n)&#123; for(int i=1;i&lt;=n;i++)&#123; fa[i] = i; &#125;&#125; 默认初始状态每个结点都为根结点。 查询 123456int find(int x)&#123; if( fa[x]==x ) return x; else return find(fa[x]);&#125; 一层层访问其父节点，直到根节点。判断两个元素是否是属于同一个集合，只需要看他们的根节点是否相同。 合并 123inline void merge(int fi,int se)&#123; fa[find(fi)] = find(se);&#125; 将第一个集合的根结点挂载到第二个集合根节点。 上述的简单合并效率是很低的，尤其在出现了很长的链的情况下，访问根节点会需要很长的时间。最重要的是大部分题目使用上述方法会超时，所以需要优化其代码。 优化一可以采用路径压缩的方式，集合合并的时候我们只关心根节点而不关心中间的遍历过程。那么我们可以在查询的时候将路径上的每个节点的父节点都改为根节点。 12345678int find(int x)&#123; if(fa[x]==x) return x; else&#123; fa[x] = find[fa[x]]; return fa[x]; &#125;&#125; 或者简写为 123int find(int x)&#123; return x== fa[x] ? x :( fa[x]=find(fa[x]) );&#125; 优化二经过路径压缩之后的并查集并不是一个只有两层的树，因为路径压缩只是在查询的时候进行，并且也只是压缩了其中一条路径。所以很多时候其结果仍然很复杂。当两颗树合并时，如果把简单的树往复杂的树上合并，最后的结果相对更简单。 所以有了一种新的优化策略，即按秩合并。 12345678910111213141516inline void init(int n)&#123; for(int i=1; i&lt;=n ; i++)&#123; fa[i] = i; rank[i]=1; &#125;&#125;inline void merge(int i, int j)&#123; int x = find(i),y=find(j); if(rank[x] &lt;= rank[y] ) fa[x] = y; else fa[y] = x; if(rank[x] == rank[y] &amp;&amp; x!=y ) rank[y]++; // 深度相同，挂载后树的高度加一。&#125; 当然懂了原理，还需要实践。可以去落谷或者leetcode刷刷题。","categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"hexo配置","slug":"hexo配置网站","date":"2021-05-16T06:32:21.000Z","updated":"2021-07-01T09:01:04.730Z","comments":true,"path":"2021/05/16/hexo配置网站/","link":"","permalink":"https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/","excerpt":"重新布置博客主题","text":"重新布置博客主题 安装所需环境首先需要安装git以及node.js。直接去对应的官网下载就好。git版本无所谓，但是node.js的版本就很重要。大部分博客主题是基于node.js v14之前的写的（node v14似乎做了一次大改），所以如果版本不匹配，会发生一些问题（错误会在本篇最后具体描述）。所以最好安装node.js v14之前的版本。 hexo主题配置首先使用 npm 安装 hexo-cli 。 npm install hexo-cli -g 然后找一个空的文件夹 执行以下命令 1234hexo init blogcd blognpm installhexo s 然后访问localhost:4000, 就能看到默认的一个hexo主题。 更换主题默认主题说实话，太丑了。得换。 可以在 hexo官网 找一个好康的主题。 首先，下载主题。我使用的是indigo主题。 1git clone https://github.com/yscoder/hexo-theme-indigo.git 然后把下载的文件夹放到blog/themes。 接下来，更新hexo 的版本。hexo v5也是大改过的版本。至少indigo主题不支持hexo v5。 1npm update hexo@4.0.0 安装 indigo所需依赖： 1234npm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-json-content --savenpm install hexo-helper-qrcode --save 修改blog 下的_config文件，修改theme 为 hexo-theme-indigo。 执行以下命令 12hexo ghexo s 就可以在本地 localhost:4000 看到新的主题。 谈谈问题版本匹配真的是一个坑，indigo主题只是说了使用hexo v3.0+ 和node v6.0+。然后下载的时候下载最新版本的hexo和node会直接g掉。 node版本不匹配会遇到的问题node 版本如果是14以上的话，执行hexo s命令是没有问题的。hexo g 本来是应该将markdown文章解析之后放入public文件夹。事实是，public里面的index.html 是一个空白文件。 hexo s能显示正常。但是当hexo d(该命令用于部署到网上)，执行的时候是把public里面的文件给提交上去。 hexo版本不匹配所遇到的问题由于hexo v5.0 将lodash从全局变量中移除。 所以 hexo g 执行的时候会出现大量的 _未定义。","categories":[{"name":"博客配置","slug":"博客配置","permalink":"https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://heugzh.github.io/tags/hexo/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"tools","slug":"tools","permalink":"https://heugzh.github.io/categories/tools/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://heugzh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"博客配置","slug":"博客配置","permalink":"https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://heugzh.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"二分查找","slug":"二分查找","permalink":"https://heugzh.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"markdown","slug":"markdown","permalink":"https://heugzh.github.io/tags/markdown/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://heugzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"考研","slug":"考研","permalink":"https://heugzh.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"并查集","slug":"并查集","permalink":"https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"hexo","slug":"hexo","permalink":"https://heugzh.github.io/tags/hexo/"}]}