{"meta":{"title":"深海的鲸的鱼塘","subtitle":"为何而愁？","description":"技术积累","author":"深海的鲸","url":"https://heugzh.github.io","root":"/"},"pages":[{"title":"about","date":"2021-05-26T08:35:41.000Z","updated":"2021-05-26T09:08:56.850Z","comments":true,"path":"about/index.html","permalink":"https://heugzh.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-16T06:30:32.000Z","updated":"2021-05-17T05:17:25.174Z","comments":true,"path":"categories/index.html","permalink":"https://heugzh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-15T05:19:04.000Z","updated":"2021-05-17T05:13:13.722Z","comments":true,"path":"tags/index.html","permalink":"https://heugzh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"并查集","slug":"并查集","date":"2021-05-18T14:51:12.000Z","updated":"2021-06-28T09:12:28.610Z","comments":true,"path":"2021/05/18/并查集/","link":"","permalink":"https://heugzh.github.io/2021/05/18/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"并查集算法的基本概念","text":"并查集算法的基本概念 并查集 并查集主要用于解决一些元素分组的问题，它管理一系列的不相交的集合。并且支持两种操作： 合并（Union）：把两个集合合并成一个集合。 查询（Find）：查询两个元素是否在同一个集合。 实现代码初始化 123456int fa[MAXN];inline void init(int n)&#123; for(int i=1;i&lt;=n;i++)&#123; fa[i] = i; &#125;&#125; 默认初始状态每个结点都为根结点。 查询 123456int find(int x)&#123; if( fa[x]==x ) return x; else return find(fa[x]);&#125; 一层层访问其父节点，直到根节点。判断两个元素是否是属于同一个集合，只需要看他们的根节点是否相同。 合并 123inline void merge(int fi,int se)&#123; fa[find(fi)] = find(se);&#125; 将第一个集合的根结点挂载到第二个集合根节点。 上述的简单合并效率是很低的，尤其在出现了很长的链的情况下，访问根节点会需要很长的时间。最重要的是大部分题目使用上述方法会超时，所以需要优化其代码。 优化一可以采用路径压缩的方式，集合合并的时候我们只关心根节点而不关心中间的遍历过程。那么我们可以在查询的时候将路径上的每个节点的父节点都改为根节点。 12345678int find(int x)&#123; if(fa[x]==x) return x; else&#123; fa[x] = find[fa[x]]; return fa[x]; &#125;&#125; 或者简写为 123int find(int x)&#123; return x== fa[x] ? x :( fa[x]=find(fa[x]) );&#125; 优化二经过路径压缩之后的并查集并不是一个只有两层的树，因为路径压缩只是在查询的时候进行，并且也只是压缩了其中一条路径。所以很多时候其结果仍然很复杂。当两颗树合并时，如果把简单的树往复杂的树上合并，最后的结果相对更简单。 所以有了一种新的优化策略，即按秩合并。 12345678910111213141516inline void init(int n)&#123; for(int i=1; i&lt;=n ; i++)&#123; fa[i] = i; rank[i]=1; &#125;&#125;inline void merge(int i, int j)&#123; int x = find(i),y=find(j); if(rank[x] &lt;= rank[y] ) fa[x] = y; else fa[y] = x; if(rank[x] == rank[y] &amp;&amp; x!=y ) rank[y]++; // 深度相同，挂载后树的高度加一。&#125; 当然懂了原理，还需要实践。可以去落谷或者leetcode刷刷题。","categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"hexo配置","slug":"hexo配置网站","date":"2021-05-16T06:32:21.000Z","updated":"2021-06-28T09:11:08.219Z","comments":true,"path":"2021/05/16/hexo配置网站/","link":"","permalink":"https://heugzh.github.io/2021/05/16/hexo%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/","excerpt":"重新布置博客主题","text":"重新布置博客主题 安装所需环境首先需要安装git以及node.js。直接去对应的官网下载就好。git版本无所谓，但是node.js的版本就很重要。大部分博客主题是基于node.js v14之前的写的（node v14似乎做了一次大改），所以如果版本不匹配，会发生一些问题（错误会在本篇最后具体描述）。所以最好安装node.js v14之前的版本。 hexo主题配置首先使用 npm 安装 hexo-cli 。 npm install hexo-cli -g 然后找一个空的文件夹 执行以下命令 1234hexo init blogcd blognpm installhexo s 然后访问localhost:4000, 就能看到默认的一个hexo主题。 更换主题默认主题说实话，太丑了。得换。 可以在 hexo官网 找一个好康的主题。 首先，下载主题。我使用的是indigo主题。 1git clone https://github.com/yscoder/hexo-theme-indigo.git 然后把下载的文件夹放到blog/themes。 接下来，更新hexo 的版本。hexo v5也是大改过的版本。至少indigo主题不支持hexo v5。 1npm update hexo@4.0.0 安装 indigo所需依赖： 1234npm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-json-content --savenpm install hexo-helper-qrcode --save 修改blog 下的_config文件，修改theme 为 hexo-theme-indigo。 执行以下命令 12hexo ghexo s 就可以在本地 localhost:4000 看到新的主题。 谈谈问题版本匹配真的是一个坑，indigo主题只是说了使用hexo v3.0+ 和node v6.0+。然后下载的时候下载最新版本的hexo和node会直接g掉。 node版本不匹配会遇到的问题node 版本如果是14以上的话，执行hexo s命令是没有问题的。hexo g 本来是应该将markdown文章解析之后放入public文件夹。事实是，public里面的index.html 是一个空白文件。 hexo s能显示正常。但是当hexo d(该命令用于部署到网上)，执行的时候是把public里面的文件给提交上去。 hexo版本不匹配所遇到的问题由于hexo v5.0 将lodash从全局变量中移除。 所以 hexo g 执行的时候会出现大量的 _未定义。","categories":[{"name":"博客配置","slug":"博客配置","permalink":"https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://heugzh.github.io/tags/hexo/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://heugzh.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"博客配置","slug":"博客配置","permalink":"https://heugzh.github.io/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://heugzh.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"hexo","slug":"hexo","permalink":"https://heugzh.github.io/tags/hexo/"}]}